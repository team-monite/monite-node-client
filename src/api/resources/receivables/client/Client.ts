/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Monite from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Receivables {
    export interface Options {
        environment?: core.Supplier<environments.MoniteEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the x-monite-version header */
        moniteVersion: core.Supplier<string>;
        /** Override the x-monite-entity-id header */
        moniteEntityId?: core.Supplier<string | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the x-monite-version header */
        moniteVersion?: string;
        /** Override the x-monite-entity-id header */
        moniteEntityId?: string | undefined;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Receivables {
    protected readonly _options: Receivables.Options;

    constructor(_options: Receivables.Options) {
        this._options = _options;
    }

    /**
     * Returns a list of [accounts receivable](https://docs.monite.com/accounts-receivable/index) documents - invoices, quotes, and credit notes - of the specified entity.
     *
     * Results can be filtered by amount, counterpart, due date, and other criteria. Multiple filters are combined using logical AND unless specified otherwise. If no documents matching the search criteria are found, the endpoint returns a successful response with an empty `data` array.
     *
     * This endpoint supports [pagination](https://docs.monite.com/api/concepts/pagination-sorting-filtering) and sorting. By default, results are sorted by the creation date in ascending order (from oldest to newest).
     *
     * #### Examples
     *
     * ##### Invoices
     *
     * * Get all overdue invoices:
     *     ```
     *     GET /receivables?type=invoice&status=overdue
     *     ```
     *
     * * Get all invoices created for the counterpart named "Solarwind" (case-insensitive):
     *
     *     ```
     *     GET /receivables?type=invoice?counterpart_name__icontains=Solarwind
     *     ```
     *
     * * Get invoices whose total amount starts from 500 EUR:
     *
     *     ```
     *     GET /receivables?type=invoice&total_amount__gte=50000
     *     ```
     *
     * * Get invoices that are due for payment in September 2024:
     *
     *     ```
     *     GET /receivables?type=invoice&due_date__gte=2024-09-01T00:00:00Z&due_date__lt=2024-10-01T00:00:00Z
     *     ```
     *
     * * Get invoices created on or after September 1, 2024:
     *
     *     ```
     *     GET /receivables?type=invoice&created_at__gte=2024-09-01T00:00:00Z
     *     ```
     *
     * * Find an invoice created from a specific quote:
     *
     *     ```
     *     GET /receivables?type=invoice?based_on=QUOTE_ID
     *     ```
     *
     * ##### Quotes
     *
     * * Get the latest created quote:
     *
     *     ```
     *     GET /receivables?type=quote&sort=created_at&order=desc&limit=1
     *     ```
     *
     * * Get the latest issued quote:
     *
     *     ```
     *     GET /receivables?type=quote&sort=issue_date&order=desc&limit=1
     *     ```
     *
     * ##### Credit notes
     *
     * * Find all credit notes created for a specific invoice:
     *
     *     ```
     *     GET /receivables?type=credit_note?based_on=INVOICE_ID
     *     ```
     *
     * @param {Monite.ReceivablesGetRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotAcceptableError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.get()
     */
    public get(
        request: Monite.ReceivablesGetRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivablePaginationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Monite.ReceivablesGetRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivablePaginationResponse>> {
        const {
            order,
            limit,
            pagination_token: paginationToken,
            id__in: idIn,
            status__in: statusIn,
            entity_user_id__in: entityUserIdIn,
            sort,
            tag_ids__in: tagIdsIn,
            tag_ids: tagIds,
            product_ids__in: productIdsIn,
            product_ids: productIds,
            project_id__in: projectIdIn,
            type: type_,
            document_id: documentId,
            document_id__contains: documentIdContains,
            document_id__icontains: documentIdIcontains,
            issue_date__gt: issueDateGt,
            issue_date__lt: issueDateLt,
            issue_date__gte: issueDateGte,
            issue_date__lte: issueDateLte,
            created_at__gt: createdAtGt,
            created_at__lt: createdAtLt,
            created_at__gte: createdAtGte,
            created_at__lte: createdAtLte,
            counterpart_id: counterpartId,
            counterpart_name: counterpartName,
            counterpart_name__contains: counterpartNameContains,
            counterpart_name__icontains: counterpartNameIcontains,
            total_amount: totalAmount,
            total_amount__gt: totalAmountGt,
            total_amount__lt: totalAmountLt,
            total_amount__gte: totalAmountGte,
            total_amount__lte: totalAmountLte,
            discounted_subtotal: discountedSubtotal,
            discounted_subtotal__gt: discountedSubtotalGt,
            discounted_subtotal__lt: discountedSubtotalLt,
            discounted_subtotal__gte: discountedSubtotalGte,
            discounted_subtotal__lte: discountedSubtotalLte,
            status,
            entity_user_id: entityUserId,
            based_on: basedOn,
            due_date__gt: dueDateGt,
            due_date__lt: dueDateLt,
            due_date__gte: dueDateGte,
            due_date__lte: dueDateLte,
            project_id: projectId,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (order != null) {
            _queryParams["order"] = order;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (paginationToken != null) {
            _queryParams["pagination_token"] = paginationToken;
        }

        if (idIn != null) {
            if (Array.isArray(idIn)) {
                _queryParams["id__in"] = idIn.map((item) => item);
            } else {
                _queryParams["id__in"] = idIn;
            }
        }

        if (statusIn != null) {
            if (Array.isArray(statusIn)) {
                _queryParams["status__in"] = statusIn.map((item) => item);
            } else {
                _queryParams["status__in"] = statusIn;
            }
        }

        if (entityUserIdIn != null) {
            if (Array.isArray(entityUserIdIn)) {
                _queryParams["entity_user_id__in"] = entityUserIdIn.map((item) => item);
            } else {
                _queryParams["entity_user_id__in"] = entityUserIdIn;
            }
        }

        if (sort != null) {
            _queryParams["sort"] = sort;
        }

        if (tagIdsIn != null) {
            if (Array.isArray(tagIdsIn)) {
                _queryParams["tag_ids__in"] = tagIdsIn.map((item) => item);
            } else {
                _queryParams["tag_ids__in"] = tagIdsIn;
            }
        }

        if (tagIds != null) {
            if (Array.isArray(tagIds)) {
                _queryParams["tag_ids"] = tagIds.map((item) => item);
            } else {
                _queryParams["tag_ids"] = tagIds;
            }
        }

        if (productIdsIn != null) {
            if (Array.isArray(productIdsIn)) {
                _queryParams["product_ids__in"] = productIdsIn.map((item) => item);
            } else {
                _queryParams["product_ids__in"] = productIdsIn;
            }
        }

        if (productIds != null) {
            if (Array.isArray(productIds)) {
                _queryParams["product_ids"] = productIds.map((item) => item);
            } else {
                _queryParams["product_ids"] = productIds;
            }
        }

        if (projectIdIn != null) {
            if (Array.isArray(projectIdIn)) {
                _queryParams["project_id__in"] = projectIdIn.map((item) => item);
            } else {
                _queryParams["project_id__in"] = projectIdIn;
            }
        }

        if (type_ != null) {
            _queryParams["type"] = type_;
        }

        if (documentId != null) {
            _queryParams["document_id"] = documentId;
        }

        if (documentIdContains != null) {
            _queryParams["document_id__contains"] = documentIdContains;
        }

        if (documentIdIcontains != null) {
            _queryParams["document_id__icontains"] = documentIdIcontains;
        }

        if (issueDateGt != null) {
            _queryParams["issue_date__gt"] = issueDateGt;
        }

        if (issueDateLt != null) {
            _queryParams["issue_date__lt"] = issueDateLt;
        }

        if (issueDateGte != null) {
            _queryParams["issue_date__gte"] = issueDateGte;
        }

        if (issueDateLte != null) {
            _queryParams["issue_date__lte"] = issueDateLte;
        }

        if (createdAtGt != null) {
            _queryParams["created_at__gt"] = createdAtGt;
        }

        if (createdAtLt != null) {
            _queryParams["created_at__lt"] = createdAtLt;
        }

        if (createdAtGte != null) {
            _queryParams["created_at__gte"] = createdAtGte;
        }

        if (createdAtLte != null) {
            _queryParams["created_at__lte"] = createdAtLte;
        }

        if (counterpartId != null) {
            _queryParams["counterpart_id"] = counterpartId;
        }

        if (counterpartName != null) {
            _queryParams["counterpart_name"] = counterpartName;
        }

        if (counterpartNameContains != null) {
            _queryParams["counterpart_name__contains"] = counterpartNameContains;
        }

        if (counterpartNameIcontains != null) {
            _queryParams["counterpart_name__icontains"] = counterpartNameIcontains;
        }

        if (totalAmount != null) {
            _queryParams["total_amount"] = totalAmount.toString();
        }

        if (totalAmountGt != null) {
            _queryParams["total_amount__gt"] = totalAmountGt.toString();
        }

        if (totalAmountLt != null) {
            _queryParams["total_amount__lt"] = totalAmountLt.toString();
        }

        if (totalAmountGte != null) {
            _queryParams["total_amount__gte"] = totalAmountGte.toString();
        }

        if (totalAmountLte != null) {
            _queryParams["total_amount__lte"] = totalAmountLte.toString();
        }

        if (discountedSubtotal != null) {
            _queryParams["discounted_subtotal"] = discountedSubtotal.toString();
        }

        if (discountedSubtotalGt != null) {
            _queryParams["discounted_subtotal__gt"] = discountedSubtotalGt.toString();
        }

        if (discountedSubtotalLt != null) {
            _queryParams["discounted_subtotal__lt"] = discountedSubtotalLt.toString();
        }

        if (discountedSubtotalGte != null) {
            _queryParams["discounted_subtotal__gte"] = discountedSubtotalGte.toString();
        }

        if (discountedSubtotalLte != null) {
            _queryParams["discounted_subtotal__lte"] = discountedSubtotalLte.toString();
        }

        if (status != null) {
            _queryParams["status"] = status;
        }

        if (entityUserId != null) {
            _queryParams["entity_user_id"] = entityUserId;
        }

        if (basedOn != null) {
            _queryParams["based_on"] = basedOn;
        }

        if (dueDateGt != null) {
            _queryParams["due_date__gt"] = dueDateGt;
        }

        if (dueDateLt != null) {
            _queryParams["due_date__lt"] = dueDateLt;
        }

        if (dueDateGte != null) {
            _queryParams["due_date__gte"] = dueDateGte;
        }

        if (dueDateLte != null) {
            _queryParams["due_date__lte"] = dueDateLte;
        }

        if (projectId != null) {
            _queryParams["project_id"] = projectId;
        }

        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                "receivables",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivablePaginationResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 406:
                    throw new Monite.NotAcceptableError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling GET /receivables.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Monite.ReceivableFacadeCreatePayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.create({
     *         based_on: "based_on",
     *         type: "invoice"
     *     })
     *
     * @example
     *     await client.receivables.create({
     *         counterpart_billing_address_id: "1323853c-0837-4a5c-8dc4-f7cb57a3efaa",
     *         counterpart_id: "34fab7ce-8cca-432a-a8a6-7e8a522e3351",
     *         counterpart_vat_id_id: "8cf9c135-8e27-4212-ad16-defed9222697",
     *         currency: "EUR",
     *         entity_bank_account_id: "5090ecd6-b0ab-40e5-a93e-4d966a3c6f3f",
     *         entity_vat_id_id: "439ea658-7096-49c8-8716-d62e8c2a2ed9",
     *         expiry_date: "2024-08-30",
     *         line_items: [{
     *                 product: {
     *                     measure_unit: {
     *                         name: "pcs."
     *                     },
     *                     name: "LG WH1000XM Monitor",
     *                     price: {
     *                         currency: "EUR",
     *                         value: 25000
     *                     }
     *                 },
     *                 quantity: 5,
     *                 vat_rate_id: "83908278-841d-4d47-bcd5-97e989201409"
     *             }],
     *         type: "quote"
     *     })
     *
     * @example
     *     await client.receivables.create({
     *         based_on: "e78de69c-c789-44ef-80bf-474b9e63b91d",
     *         type: "invoice"
     *     })
     *
     * @example
     *     await client.receivables.create({
     *         based_on: "e977db242-e7d5-4d2e-83cf-a1f5051ed40a",
     *         type: "credit_note"
     *     })
     */
    public create(
        request: Monite.ReceivableFacadeCreatePayload,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Monite.ReceivableFacadeCreatePayload,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                "receivables",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling POST /receivables.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get field requirements for invoice creation given the entity and counterpart details.
     *
     * @param {Monite.GetReceivablesRequiredFieldsRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getReceivablesRequiredFields()
     */
    public getReceivablesRequiredFields(
        request: Monite.GetReceivablesRequiredFieldsRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableRequiredFields> {
        return core.HttpResponsePromise.fromPromise(this.__getReceivablesRequiredFields(request, requestOptions));
    }

    private async __getReceivablesRequiredFields(
        request: Monite.GetReceivablesRequiredFieldsRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableRequiredFields>> {
        const {
            counterpart_id: counterpartId,
            counterpart_billing_address_id: counterpartBillingAddressId,
            counterpart_country: counterpartCountry,
            counterpart_type: counterpartType,
            entity_vat_id_id: entityVatIdId,
            counterpart_vat_id_id: counterpartVatIdId,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (counterpartId != null) {
            _queryParams["counterpart_id"] = counterpartId;
        }

        if (counterpartBillingAddressId != null) {
            _queryParams["counterpart_billing_address_id"] = counterpartBillingAddressId;
        }

        if (counterpartCountry != null) {
            _queryParams["counterpart_country"] = counterpartCountry;
        }

        if (counterpartType != null) {
            _queryParams["counterpart_type"] = counterpartType;
        }

        if (entityVatIdId != null) {
            _queryParams["entity_vat_id_id"] = entityVatIdId;
        }

        if (counterpartVatIdId != null) {
            _queryParams["counterpart_vat_id_id"] = counterpartVatIdId;
        }

        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                "receivables/required_fields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableRequiredFields, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling GET /receivables/required_fields.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This is a POST version of the `GET /receivables` endpoint. Use it to send search and filter parameters in the request body instead of the URL query string in case the query is too long and exceeds the URL length limit of your HTTP client.
     *
     * @param {Monite.ReceivablesSearchRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotAcceptableError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.postReceivablesSearch({
     *         status: "draft",
     *         type: "invoice"
     *     })
     */
    public postReceivablesSearch(
        request: Monite.ReceivablesSearchRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivablePaginationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__postReceivablesSearch(request, requestOptions));
    }

    private async __postReceivablesSearch(
        request: Monite.ReceivablesSearchRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivablePaginationResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                "receivables/search",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivablePaginationResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 406:
                    throw new Monite.NotAcceptableError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling POST /receivables/search.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a list of placeholders that can be used in email templates for customization.
     *
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getVariables()
     */
    public getVariables(
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableTemplatesVariablesObjectList> {
        return core.HttpResponsePromise.fromPromise(this.__getVariables(requestOptions));
    }

    private async __getVariables(
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableTemplatesVariablesObjectList>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                "receivables/variables",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Monite.ReceivableTemplatesVariablesObjectList,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling GET /receivables/variables.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the details of an existing accounts receivable invoice, quote, or credit note with the specified ID.
     *
     * The response fields vary depending on the document type. Use the `type` field to distinguish between different document types.
     *
     * Entity users with the `receivable.read.allowed_for_own` permission (rather than `allowed`) can access only documents that they created themselves.
     *
     * @param {string} receivableId - ID of an existing invoice, quote, or credit note that you want to retrieve.
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getById("receivable_id")
     */
    public getById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getById(receivableId, requestOptions));
    }

    private async __getById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError("Timeout exceeded when calling GET /receivables/{receivable_id}.");
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.deleteById("receivable_id")
     */
    public deleteById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteById(receivableId, requestOptions));
    }

    private async __deleteById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling DELETE /receivables/{receivable_id}.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Monite.ReceivableUpdatePayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.updateById("receivable_id", {
     *         quote: {}
     *     })
     */
    public updateById(
        receivableId: string,
        request: Monite.ReceivableUpdatePayload,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateById(receivableId, request, requestOptions));
    }

    private async __updateById(
        receivableId: string,
        request: Monite.ReceivableUpdatePayload,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling PATCH /receivables/{receivable_id}.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Only quotes in the `issued` status can be accepted.
     *
     * When a quote is accepted, Monite automatically creates a draft invoice based on this quote. To find the newly created invoice, use `GET /receivables?based_on=QUOTE_ID`.
     *
     * @param {string} receivableId
     * @param {Monite.QuoteAcceptRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.acceptById("receivable_id", {
     *         signature: {
     *             email: "theo@example.com",
     *             full_name: "Theo Quinn",
     *             signature_image: "iVBORw0KGgoAAAANSUhEUg.....AAABJRU5ErkJggg=="
     *         }
     *     })
     *
     * @example
     *     await client.receivables.acceptById("receivable_id")
     */
    public acceptById(
        receivableId: string,
        request: Monite.QuoteAcceptRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.SuccessResult> {
        return core.HttpResponsePromise.fromPromise(this.__acceptById(receivableId, request, requestOptions));
    }

    private async __acceptById(
        receivableId: string,
        request: Monite.QuoteAcceptRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.SuccessResult>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/accept`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.SuccessResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/accept.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.cancelById("receivable_id")
     */
    public cancelById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__cancelById(receivableId, requestOptions));
    }

    private async __cancelById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/cancel.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a copy of an existing accounts receivable invoice or quote. The original document can be in any status. The cloned document will have the `draft` status.
     *
     * Cloning a document requires that all of the referenced resource IDs (counterpart ID, product IDs, and others) still exist.
     *
     * Most of the original document's data is copied as is, with a few exceptions:
     *
     *  * Some fields are not copied: `attachments`, `document_id`, `issue_date`, quote `expiry_date`.
     *  * Counterpart details, entity bank account details, and entity VAT number are fetched anew from their corresponding IDs.
     *    This means, for example, that if the counterpart details have been changed since the original invoice or quote was created,
     *    the cloned document will use the current counterpart details rather than the old details from the original document.
     *
     * @param {string} receivableId - ID of an existing invoice or quote that you want to clone.
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.cloneById("receivable_id")
     */
    public cloneById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cloneById(receivableId, requestOptions));
    }

    private async __cloneById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/clone`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/clone.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Only quotes in the `issued` status can be declined.
     *
     * @param {string} receivableId
     * @param {Monite.ReceivableDeclinePayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.declineById("receivable_id")
     */
    public declineById(
        receivableId: string,
        request: Monite.ReceivableDeclinePayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.SuccessResult> {
        return core.HttpResponsePromise.fromPromise(this.__declineById(receivableId, request, requestOptions));
    }

    private async __declineById(
        receivableId: string,
        request: Monite.ReceivableDeclinePayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.SuccessResult>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/decline`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.SuccessResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/decline.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the history of the specified accounts receivable document. The history contains all revisions of the document, status updates, and other events that occurred during the document's lifecycle. For more information, see [Document history](https://docs.monite.com/accounts-receivable/document-history).
     *
     * You can filter the history by the date range and event type. Events are sorted from oldest to newest by default.
     *
     * @param {string} receivableId - ID of the accounts receivable document whose history you want to get.
     * @param {Monite.ReceivablesGetHistoryRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getHistory("receivable_id")
     */
    public getHistory(
        receivableId: string,
        request: Monite.ReceivablesGetHistoryRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableHistoryPaginationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getHistory(receivableId, request, requestOptions));
    }

    private async __getHistory(
        receivableId: string,
        request: Monite.ReceivablesGetHistoryRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableHistoryPaginationResponse>> {
        const {
            order,
            limit,
            pagination_token: paginationToken,
            sort,
            event_type__in: eventTypeIn,
            entity_user_id__in: entityUserIdIn,
            timestamp__gt: timestampGt,
            timestamp__lt: timestampLt,
            timestamp__gte: timestampGte,
            timestamp__lte: timestampLte,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (order != null) {
            _queryParams["order"] = order;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (paginationToken != null) {
            _queryParams["pagination_token"] = paginationToken;
        }

        if (sort != null) {
            _queryParams["sort"] = sort;
        }

        if (eventTypeIn != null) {
            if (Array.isArray(eventTypeIn)) {
                _queryParams["event_type__in"] = eventTypeIn.map((item) => item);
            } else {
                _queryParams["event_type__in"] = eventTypeIn;
            }
        }

        if (entityUserIdIn != null) {
            if (Array.isArray(entityUserIdIn)) {
                _queryParams["entity_user_id__in"] = entityUserIdIn.map((item) => item);
            } else {
                _queryParams["entity_user_id__in"] = entityUserIdIn;
            }
        }

        if (timestampGt != null) {
            _queryParams["timestamp__gt"] = timestampGt;
        }

        if (timestampLt != null) {
            _queryParams["timestamp__lt"] = timestampLt;
        }

        if (timestampGte != null) {
            _queryParams["timestamp__gte"] = timestampGte;
        }

        if (timestampLte != null) {
            _queryParams["timestamp__lte"] = timestampLte;
        }

        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/history`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Monite.ReceivableHistoryPaginationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling GET /receivables/{receivable_id}/history.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns a single record from the change history of the specified accounts receivable document.
     *
     * @param {string} receivableHistoryId - ID of the history record to return. You can get these IDs from `GET /receivables/{receivable_id}/history`.
     * @param {string} receivableId - ID of the accounts receivable document whose history you want to get.
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getHistoryById("receivable_history_id", "receivable_id")
     */
    public getHistoryById(
        receivableHistoryId: string,
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableHistoryResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__getHistoryById(receivableHistoryId, receivableId, requestOptions),
        );
    }

    private async __getHistoryById(
        receivableHistoryId: string,
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableHistoryResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/history/${encodeURIComponent(receivableHistoryId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableHistoryResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling GET /receivables/{receivable_id}/history/{receivable_history_id}.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.issueById("receivable_id")
     */
    public issueById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__issueById(receivableId, requestOptions));
    }

    private async __issueById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/issue`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/issue.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Replace all line items of an existing invoice or quote with a new list of line items.
     *
     * @param {string} receivableId
     * @param {Monite.UpdateLineItems} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.updateLineItemsById("receivable_id", {
     *         data: [{
     *                 quantity: 1.1
     *             }]
     *     })
     */
    public updateLineItemsById(
        receivableId: string,
        request: Monite.UpdateLineItems,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.LineItemsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateLineItemsById(receivableId, request, requestOptions));
    }

    private async __updateLineItemsById(
        receivableId: string,
        request: Monite.UpdateLineItems,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.LineItemsResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/line_items`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.LineItemsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling PUT /receivables/{receivable_id}/line_items.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Monite.ReceivablesGetMailsRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getMails("receivable_id")
     */
    public getMails(
        receivableId: string,
        request: Monite.ReceivablesGetMailsRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableMailPaginationResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMails(receivableId, request, requestOptions));
    }

    private async __getMails(
        receivableId: string,
        request: Monite.ReceivablesGetMailsRequest = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableMailPaginationResponse>> {
        const {
            order,
            limit,
            pagination_token: paginationToken,
            sort,
            status,
            status__in: statusIn,
            created_at__gt: createdAtGt,
            created_at__lt: createdAtLt,
            created_at__gte: createdAtGte,
            created_at__lte: createdAtLte,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (order != null) {
            _queryParams["order"] = order;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (paginationToken != null) {
            _queryParams["pagination_token"] = paginationToken;
        }

        if (sort != null) {
            _queryParams["sort"] = sort;
        }

        if (status != null) {
            _queryParams["status"] = status;
        }

        if (statusIn != null) {
            if (Array.isArray(statusIn)) {
                _queryParams["status__in"] = statusIn.map((item) => item);
            } else {
                _queryParams["status__in"] = statusIn;
            }
        }

        if (createdAtGt != null) {
            _queryParams["created_at__gt"] = createdAtGt;
        }

        if (createdAtLt != null) {
            _queryParams["created_at__lt"] = createdAtLt;
        }

        if (createdAtGte != null) {
            _queryParams["created_at__gte"] = createdAtGte;
        }

        if (createdAtLte != null) {
            _queryParams["created_at__lte"] = createdAtLte;
        }

        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/mails`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Monite.ReceivableMailPaginationResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling GET /receivables/{receivable_id}/mails.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {string} mailId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getMailById("receivable_id", "mail_id")
     */
    public getMailById(
        receivableId: string,
        mailId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableMailResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getMailById(receivableId, mailId, requestOptions));
    }

    private async __getMailById(
        receivableId: string,
        mailId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableMailResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/mails/${encodeURIComponent(mailId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableMailResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling GET /receivables/{receivable_id}/mails/{mail_id}.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Monite.ReceivablePaidPayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.markAsPaidById("receivable_id")
     */
    public markAsPaidById(
        receivableId: string,
        request: Monite.ReceivablePaidPayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(this.__markAsPaidById(receivableId, request, requestOptions));
    }

    private async __markAsPaidById(
        receivableId: string,
        request: Monite.ReceivablePaidPayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/mark_as_paid`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/mark_as_paid.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deprecated. Use `POST /payment_records` to record an invoice payment.
     *
     * @param {string} receivableId
     * @param {Monite.ReceivablePartiallyPaidPayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.markAsPartiallyPaidById("receivable_id", {
     *         amount_paid: 1
     *     })
     */
    public markAsPartiallyPaidById(
        receivableId: string,
        request: Monite.ReceivablePartiallyPaidPayload,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__markAsPartiallyPaidById(receivableId, request, requestOptions),
        );
    }

    private async __markAsPartiallyPaidById(
        receivableId: string,
        request: Monite.ReceivablePartiallyPaidPayload,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/mark_as_partially_paid`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/mark_as_partially_paid.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Monite.ReceivableUncollectiblePayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.markAsUncollectibleById("receivable_id")
     */
    public markAsUncollectibleById(
        receivableId: string,
        request: Monite.ReceivableUncollectiblePayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__markAsUncollectibleById(receivableId, request, requestOptions),
        );
    }

    private async __markAsUncollectibleById(
        receivableId: string,
        request: Monite.ReceivableUncollectiblePayload = {},
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/mark_as_uncollectible`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/mark_as_uncollectible.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.getPdfLinkById("receivable_id")
     */
    public getPdfLinkById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableFileUrl> {
        return core.HttpResponsePromise.fromPromise(this.__getPdfLinkById(receivableId, requestOptions));
    }

    private async __getPdfLinkById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableFileUrl>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/pdf_link`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableFileUrl, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling GET /receivables/{receivable_id}/pdf_link.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * You can preview emails only for documents in the following statuses:
     *
     *  * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
     *    In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
     *  * Quotes: `draft`, `issued`.
     *  * Credit notes: `draft`, `issued`.
     *
     * @param {string} receivableId
     * @param {Monite.ReceivablePreviewRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.previewById("receivable_id", {
     *         body_text: "body_text",
     *         subject_text: "subject_text"
     *     })
     */
    public previewById(
        receivableId: string,
        request: Monite.ReceivablePreviewRequest,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivablePreviewResponse> {
        return core.HttpResponsePromise.fromPromise(this.__previewById(receivableId, request, requestOptions));
    }

    private async __previewById(
        receivableId: string,
        request: Monite.ReceivablePreviewRequest,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivablePreviewResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/preview`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivablePreviewResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/preview.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Only documents in the following statuses can be sent via email:
     *
     *  * Invoices: `draft`, `issued`, `overdue`, `partially_paid`, `paid`.
     *    In the [non-compliant mode](https://docs.monite.com/accounts-receivable/regulatory-compliance/invoice-compliance): also `canceled`.
     *  * Quotes: `draft`, `issued`.
     *  * Credit notes: `draft`, `issued`.
     *
     * Draft documents are automatically moved to the `issued` status before sending.
     *
     * For more information, see [Send an invoice via email](https://docs.monite.com/accounts-receivable/invoices/create#send-via-email).
     *
     * @param {string} receivableId
     * @param {Monite.ReceivableSendRequest} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.sendById("receivable_id", {
     *         body_text: "body_text",
     *         subject_text: "subject_text"
     *     })
     */
    public sendById(
        receivableId: string,
        request: Monite.ReceivableSendRequest,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivableSendResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendById(receivableId, request, requestOptions));
    }

    private async __sendById(
        receivableId: string,
        request: Monite.ReceivableSendRequest,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivableSendResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/send`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivableSendResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/send.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Monite.ReceivableSendTestReminderPayload} request
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.ConflictError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.sendTestReminderById("receivable_id", {
     *         reminder_type: "term_1"
     *     })
     */
    public sendTestReminderById(
        receivableId: string,
        request: Monite.ReceivableSendTestReminderPayload,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivablesSendResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendTestReminderById(receivableId, request, requestOptions));
    }

    private async __sendTestReminderById(
        receivableId: string,
        request: Monite.ReceivableSendTestReminderPayload,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivablesSendResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/send_test_reminder`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivablesSendResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Monite.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/send_test_reminder.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} receivableId
     * @param {Receivables.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Monite.BadRequestError}
     * @throws {@link Monite.UnauthorizedError}
     * @throws {@link Monite.ForbiddenError}
     * @throws {@link Monite.NotFoundError}
     * @throws {@link Monite.UnprocessableEntityError}
     * @throws {@link Monite.TooManyRequestsError}
     *
     * @example
     *     await client.receivables.verifyById("receivable_id")
     */
    public verifyById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): core.HttpResponsePromise<Monite.ReceivablesVerifyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__verifyById(receivableId, requestOptions));
    }

    private async __verifyById(
        receivableId: string,
        requestOptions?: Receivables.RequestOptions,
    ): Promise<core.WithRawResponse<Monite.ReceivablesVerifyResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "x-monite-version": requestOptions?.moniteVersion,
                "x-monite-entity-id": requestOptions?.moniteEntityId,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MoniteEnvironment.Sandbox,
                `receivables/${encodeURIComponent(receivableId)}/verify`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Monite.ReceivablesVerifyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Monite.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Monite.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Monite.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Monite.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 422:
                    throw new Monite.UnprocessableEntityError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Monite.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.MoniteError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MoniteError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MoniteTimeoutError(
                    "Timeout exceeded when calling POST /receivables/{receivable_id}/verify.",
                );
            case "unknown":
                throw new errors.MoniteError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
