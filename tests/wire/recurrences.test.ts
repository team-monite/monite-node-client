/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool.js";
import { MoniteClient } from "../../src/Client";

describe("Recurrences", () => {
    test("get", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    id: "id",
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    automation_level: "draft",
                    body_text: "body_text",
                    current_iteration: 1,
                    day_of_month: "first_day",
                    end_date: "end_date",
                    frequency: "day",
                    interval: 1,
                    invoice_id: "invoice_id",
                    iterations: [{ issue_at: "issue_at", status: "pending" }],
                    max_occurrences: 1,
                    start_date: "start_date",
                    start_month: 1,
                    start_year: 1,
                    status: "active",
                    subject_text: "subject_text",
                },
            ],
        };
        server.mockEndpoint().get("/recurrences").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.recurrences.get();
        expect(response).toEqual({
            data: [
                {
                    id: "id",
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    automation_level: "draft",
                    body_text: "body_text",
                    current_iteration: 1,
                    day_of_month: "first_day",
                    end_date: "end_date",
                    frequency: "day",
                    interval: 1,
                    invoice_id: "invoice_id",
                    iterations: [
                        {
                            issue_at: "issue_at",
                            status: "pending",
                        },
                    ],
                    max_occurrences: 1,
                    start_date: "start_date",
                    start_month: 1,
                    start_year: 1,
                    status: "active",
                    subject_text: "subject_text",
                },
            ],
        });
    });

    test("create", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = { invoice_id: "invoice_id" };
        const rawResponseBody = {
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                { issue_at: "issue_at", issued_invoice_id: "issued_invoice_id", iteration: 1, status: "pending" },
            ],
            max_occurrences: 1,
            recipients: { bcc: ["bcc"], cc: ["cc"], to: ["to"] },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        };
        server
            .mockEndpoint()
            .post("/recurrences")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.recurrences.create({
            invoice_id: "invoice_id",
        });
        expect(response).toEqual({
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                {
                    issue_at: "issue_at",
                    issued_invoice_id: "issued_invoice_id",
                    iteration: 1,
                    status: "pending",
                },
            ],
            max_occurrences: 1,
            recipients: {
                bcc: ["bcc"],
                cc: ["cc"],
                to: ["to"],
            },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        });
    });

    test("get_by_id", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                { issue_at: "issue_at", issued_invoice_id: "issued_invoice_id", iteration: 1, status: "pending" },
            ],
            max_occurrences: 1,
            recipients: { bcc: ["bcc"], cc: ["cc"], to: ["to"] },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        };
        server
            .mockEndpoint()
            .get("/recurrences/recurrence_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.recurrences.getById("recurrence_id");
        expect(response).toEqual({
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                {
                    issue_at: "issue_at",
                    issued_invoice_id: "issued_invoice_id",
                    iteration: 1,
                    status: "pending",
                },
            ],
            max_occurrences: 1,
            recipients: {
                bcc: ["bcc"],
                cc: ["cc"],
                to: ["to"],
            },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        });
    });

    test("update_by_id", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                { issue_at: "issue_at", issued_invoice_id: "issued_invoice_id", iteration: 1, status: "pending" },
            ],
            max_occurrences: 1,
            recipients: { bcc: ["bcc"], cc: ["cc"], to: ["to"] },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        };
        server
            .mockEndpoint()
            .patch("/recurrences/recurrence_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.recurrences.updateById("recurrence_id");
        expect(response).toEqual({
            id: "id",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            automation_level: "draft",
            body_text: "body_text",
            current_iteration: 1,
            day_of_month: "first_day",
            end_date: "end_date",
            frequency: "day",
            interval: 1,
            invoice_id: "invoice_id",
            iterations: [
                {
                    issue_at: "issue_at",
                    issued_invoice_id: "issued_invoice_id",
                    iteration: 1,
                    status: "pending",
                },
            ],
            max_occurrences: 1,
            recipients: {
                bcc: ["bcc"],
                cc: ["cc"],
                to: ["to"],
            },
            start_date: "start_date",
            start_month: 1,
            start_year: 1,
            status: "active",
            subject_text: "subject_text",
        });
    });

    test("cancel_by_id", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        server.mockEndpoint().post("/recurrences/recurrence_id/cancel").respondWith().statusCode(200).build();

        const response = await client.recurrences.cancelById("recurrence_id");
        expect(response).toEqual(undefined);
    });

    test("post_recurrences_id_pause", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/recurrences/recurrence_id/pause")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.recurrences.postRecurrencesIdPause("recurrence_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("post_recurrences_id_resume", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/recurrences/recurrence_id/resume")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.recurrences.postRecurrencesIdResume("recurrence_id");
        expect(response).toEqual({
            key: "value",
        });
    });
});
