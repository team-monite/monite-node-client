/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { MoniteClient } from "../../src/Client";
import * as Monite from "../../src/api/index";

describe("PaymentRecords", () => {
    test("get", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    id: "id",
                    amount: 1,
                    currency: "AED",
                    entity_user_id: "entity_user_id",
                    history: [{ status: "created", timestamp: "2024-01-15T09:30:00Z" }],
                    is_external: true,
                    object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
                    overpaid_amount: 1,
                    paid_at: "2024-01-15T09:30:00Z",
                    payment_intent_id: "payment_intent_id",
                    payment_intent_status: "payment_intent_status",
                    payment_method: "payment_method",
                    planned_payment_date: "planned_payment_date",
                    status: "status",
                },
            ],
            next_pagination_token: "next_pagination_token",
            prev_pagination_token: "prev_pagination_token",
        };
        server.mockEndpoint().get("/payment_records").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.paymentRecords.get();
        expect(response).toEqual({
            data: [
                {
                    id: "id",
                    amount: 1,
                    currency: "AED",
                    entity_user_id: "entity_user_id",
                    history: [
                        {
                            status: "created",
                            timestamp: "2024-01-15T09:30:00Z",
                        },
                    ],
                    is_external: true,
                    object: {
                        id: "id",
                        new_status: "new_status",
                        old_status: "old_status",
                        type: "receivable",
                    },
                    overpaid_amount: 1,
                    paid_at: "2024-01-15T09:30:00Z",
                    payment_intent_id: "payment_intent_id",
                    payment_intent_status: "payment_intent_status",
                    payment_method: "payment_method",
                    planned_payment_date: "planned_payment_date",
                    status: "status",
                },
            ],
            next_pagination_token: "next_pagination_token",
            prev_pagination_token: "prev_pagination_token",
        });
    });

    test("create", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = { amount: 1, currency: "AED", object: { id: "id", type: "receivable" } };
        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/payment_records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.create({
            amount: 1,
            currency: "AED",
            object: {
                id: "id",
                type: "receivable",
            },
        });
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });

    test("get_by_id", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .get("/payment_records/payment_record_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.getById("payment_record_id");
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });

    test("patch_payment_records_id", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .patch("/payment_records/payment_record_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.patchPaymentRecordsId("payment_record_id");
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });

    test("post_payment_records_id_cancel", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/payment_records/payment_record_id/cancel")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.postPaymentRecordsIdCancel("payment_record_id", {});
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });

    test("post_payment_records_id_mark_as_succeeded", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paid_at: "2024-01-15T09:30:00Z" };
        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/payment_records/payment_record_id/mark_as_succeeded")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.postPaymentRecordsIdMarkAsSucceeded("payment_record_id", {
            paid_at: "2024-01-15T09:30:00Z",
        });
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });

    test("post_payment_records_id_start_processing", async () => {
        const server = mockServerPool.createServer();
        const client = new MoniteClient({
            token: "test",
            moniteVersion: "test",
            moniteEntityId: "test",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [{ entity_user_id: "entity_user_id", status: "created", timestamp: "2024-01-15T09:30:00Z" }],
            is_external: true,
            object: { id: "id", new_status: "new_status", old_status: "old_status", type: "receivable" },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/payment_records/payment_record_id/start_processing")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.paymentRecords.postPaymentRecordsIdStartProcessing("payment_record_id", {});
        expect(response).toEqual({
            id: "id",
            amount: 1,
            currency: "AED",
            entity_user_id: "entity_user_id",
            history: [
                {
                    entity_user_id: "entity_user_id",
                    status: "created",
                    timestamp: "2024-01-15T09:30:00Z",
                },
            ],
            is_external: true,
            object: {
                id: "id",
                new_status: "new_status",
                old_status: "old_status",
                type: "receivable",
            },
            overpaid_amount: 1,
            paid_at: "2024-01-15T09:30:00Z",
            payment_intent_id: "payment_intent_id",
            payment_intent_status: "payment_intent_status",
            payment_method: "payment_method",
            planned_payment_date: "planned_payment_date",
            status: "status",
        });
    });
});
